<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>1 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem sm04-3: asm/hacks/rop</h3>
<p>Return Oriented Programming (ROP) - это техника эксплуатации
        уязвимостей в ПО, используя которую, злоумышленник добивается исполнения
        необходимого ему кода.</p>
<p>Основная идея техники заключается в том, что злоумышленник находит
        необходимые ему инструкции среди уже присутствующего кода, и меняет ход
        программы нужным ему образом, изменяя стек вызовов (либо напрямую, либо
        путём атаки на переполнение буфера, либо другими способами). Комбинируя
        таким образом нужные ему участки кода, злоумышленник добивается нужного
        ему поведения программы.</p>
<p>Разберём атаку на простейшем примере. Дано: в программе присутствует
        функция <code>send_nukes</code>, которую мы (как злоумышленник) хотим
        выполнить; основной код будет вызывать написанную нами функцию
        <code>solution</code>, но нам нельзя пользоваться инструкциями
        <code>call</code>, <code>jmp</code> и прочими. Вспомним, что происходит,
        когда мы завершаем свою функцию
        инструкцией <code>ret</code>: со стека берётся адрес возврата, и дальше следует
        исполнение инструкций по этому адресу. Поэтому простейшая ROP-атака, при
        условии, что программа выполняет наш код, выглядит следующим
        образом:</p>
<pre>
    .global solution
solution:
    push    $send_nukes
    ret
        </pre>
<p>Напишите подпрограмму rop, соответствующую сигнатуре <code>void rop(void)</code>,
        с помощью которой добейтесь того, чтобы в процессе работы программы на
        стандартный поток вывода была напечатана строка <code>Hello, world!</code>
        (с переводом строки на конце). Иными словами должна сфоримровать правильный стек с помощью инсутркций lea и push и запустить rop исполнение.</p>
<p>Написанная функция (кроме меток и директив .global) может содержать только инструкции <code>push</code>, <code>lea</code> и РОВНО ОДНУ инструкцию <code>ret</code>.</p>
<p>Написанная вами функция не должна содержать инструкций вызова (<code>call</code>)
        или инструкций перехода, условного или безусловного, <code>mov</code> и прочие</p>
<p>Итоговый исполняемый файл будет компилироваться следующей командой:
        <code>gcc main.c functions.S solution.S</code>,
        где <code>solution.S</code> - это сдаваемый вами файл.</p>
<p>main.c:</p>
<pre>
void rop(void);
int main() {
    rop();
}</pre>
<p>functions.S:</p>
<pre>
    .intel_syntax noprefix
    .text
    .global f1
f1:
    lea  rax, [rip + str0]
    push rax
    push rax
    pop  rdi
    xor  rax, rax
    call printf
    pop  rdi
    ret

    .global str0
    .global str1
    .global str2
str0:
    .asciz "Fail\n"
str1:
    .asciz "Hello, "
str2:
    .asciz "world!\n"
        </pre>
<p>P.S. не забывайте, что asm компилируется в байткод, и каждая инструкция кодируется всегда одинаковым соответствующим ей числом байт.</p>
<p> </p></body></html>